{"name": "Максимальное паросочетание", "text": "Максимальное паросочетание\nГраф (V, E) называется двудольным, если множество его вершин V можно разбить на два подмножества A и B такие, что любое ребро из E соединяет вершину из A с вершиной из B.\nПаросочетанием P называется любое подмножество E такое, что никакие два ребра из него не имеют общей вершины.\nМаксимальное паросочетание - это паросочетание, число рёбер в котором максимально.\nНайдите максимальное паросочетание в заданном двудольном графе.\nВходные данные\nВ первой строке заданы три числа n, m и k (1 ≤ n, m ≤ 100, 1 ≤ k ≤ 10000), где n - число вершин во множестве A, m - число вершин в B, а k - количество рёбер в графе. Каждая из следующих k строк содержит по два числа ui и vi, означающих, что вершина ui множества A соединена с ребром vi множества B. Вершины во множествах A и B нумеруются по отдельности, начиная с единицы. Все входные числа целые.\nВыходные данные\nВ первой строке выведите количество l рёбер в максимальном паросочетании. Далее выведите l строк, по два числа в каждой. Числа aj и bj, стоящие в j-ой из этих строк, означают, что паросочетание взято между вершиной aj множества A и вершиной bj множества B. Взятые рёбра должны образовывать максимальное паросочетание.", "compiler": "Judge C++", "send_date": "28 июн. 2017 г., 10:06:14", "time": 2.7, "memory": 1752, "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 110\nvector<vector<int> > g;\nvector<int> used, mt;\nint n,m,k;\nint dfs(int v)\n{\n  if (used[v]) return 0;\n  used[v] = 1;\n  for (int i = 0; i < g[v].size(); i++)\n  {\n    int to = g[v][i];\n    if (mt[to] == -1 || dfs(mt[to]))\n    {\n      mt[to] = v;\n      return 1;\n    }\n  }\n  return 0;\n}\nvoid func()\n{\n  int i, to;\n  mt.assign (m+1, -1);\n  for (i = 1; i <= n; i++)\n  {\n    used.assign(n+1, 0);\n    dfs(i);\n  }\n}\nint main()\n{\n    int a,b;\n    cin >> n >> m >> k;\n    g.resize(n+1);\n    for(int i = 0; i < k; i++){\n        cin >> a >> b;\n        g[a].push_back(b);\n    }\n    func();\n    int flow,i;\n    for(flow = 0, i = 1; i <= m; i++)\n        if(mt[i] != -1)  flow++;\n    cout << flow << endl;\n    for(i = 1; i<=m;i++)\n        if(mt[i] != -1) cout << mt[i] << \" \" << i << endl;\n\n}", "link": "https://www.e-olymp.com/ru/problems/1989"}