{"name": "Минимальный каркас", "text": "Минимальный каркас\nОпределить вес минимального остовного дерева для неориентированного взвешенного связного графа.\nВходные данные\nВ первой строке находится количество вершин n и рёбер m (1 ≤ n ≤ 100, 1 ≤ m ≤ 6000) в графе. В каждой из последующих m строк записано по тройке чисел a, b, c, где a и b - номера вершин, соединённых ребром, а c - вес ребра (натуральное число, не превышающее 30000).\nВыходные данные\nВывести вес минимального остовного дерева.", "compiler": "Judge C++", "send_date": "24 сент. 2017 г., 15:49:36", "time": 3.68, "memory": 3748, "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct E{\n    int a, b, dist;\n};\nvector <E> g(100001);\nvector <int> mas(20001), len(20001);\nint Repr(int n){\n    if(n == mas[n]) return n;\n    return mas[n] = Repr(mas[n]);\n}\nint Union(int x, int y){\n    x = Repr(x);\n    y = Repr(y);\n    if(x == y) return 0;\n    if(len[x] < len[y]) swap(x,y);\n    mas[y] = x;\n    len[x] += len[y];\n    return 1;\n}\nint f(E a, E b){\n    return (a.dist < b.dist);\n}\nmain()\n{\n    int n, m, a, b, c;\n    cin >> n >> m;\n    g.resize(m);\n    len.resize(n);\n    mas.resize(n);\n    for(int i = 0; i < n; i++) mas[i] = i, len[i]=1;\n    for(int i = 0; i < m; i++){\n        cin >> a >> b >> g[i].dist;\n        g[i].a = a;\n        g[i].b = b;\n    }\n    sort(g.begin(), g.end(), f);\n    int res = 0;\n    for(int i = 0; i < m; i++)\n        if(Union(g[i].a, g[i].b))\n            res += g[i].dist;\n    cout << res << endl;\n\n}", "link": "https://www.e-olymp.com/ru/problems/981"}