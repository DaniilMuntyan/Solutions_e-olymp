{"name": "Полный граф - 2", "text": "Полный граф - 2\nОбсуждая личную жизнь всевозможных злодеев, мы обделили своим вниманием графа Дуку. Так вот, граф Дуку на досуге любит складывать оригами. Он давно систематизировал свои познания в этой области следующим образом: всего граф знает n фигурок, причем для некоторых из них он знает, как получать из одной другую. Для обучения начинающих ситхов Дуку разработал специальную таблицу. В ячейке [i, j] таблицы стоит \"1\", если граф может получить из фигурки i фигурку j одним сгибом. Иначе там стоит \"0\". Изначально в руках у графа Дуку чистый лист, то есть фигурка номер x по его системе, сложить же он желает журавлика – фигурку номер y.\nНайдите, за сколько операций граф достигнет желаемого.\nВходные данные\nВ первой строке находится число n (1 ≤ n ≤ 1000). В следующих n строках задана таблица Дуку. В (n + 1) - ой строке стоят числа x и y.\nВыходные данные\nВыведите минимальное количество операций, которые придется осуществить. Если же коварным планам Графа не суждено осуществиться, выведите \"-1\".", "compiler": "Judge C++", "send_date": "15 окт. 2017 г., 17:54:24", "time": 4.02, "memory": 1752, "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <int> d(1001);\nvector <int> g[1001];\nqueue <int> q;\nint n,j,i,a,x,y;\nvoid BFS(int s, int f)\n{\n    d[s]=1;\n    q.push(s);\n    while(!q.empty())\n    {\n        int k = q.front();\n        q.pop();\n        for(i=0;i<g[k].size();i++)\n        {\n            if(!d[g[k][i]])\n            {\n                d[g[k][i]] = d[k]+1;\n                q.push(g[k][i]);\n                if(g[k][i]==f)\n                    return;\n            }\n        }\n    }\n}\nint main()\n{\n    cin >> n;\n    for(i=1;i<=n;i++)\n        for(j=1;j<=n;j++)\n        {\n            cin>>a;\n            if(a)\n                g[i].push_back(j);\n\n        }\n    cin >> x >> y;\n    BFS(x,y);\n    cout << d[y] - 1 << endl;\n}", "link": "https://www.e-olymp.com/ru/problems/5338"}