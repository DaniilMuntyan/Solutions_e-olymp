{"name": "Максимальная сумма на дереве", "text": "Максимальная сумма на дереве\nИмеется дерево из n вершин, где вершина номер i (1 ≤ i ≤ n) имеет ci монет. Вам следует выбрать такое подмножество вершин, в котором никакие две из них не являются соседними (то есть вершины соединенные ребром), а сумма монет в выбранных вершинах наибольшая.\nВходные данные\nПервая строка содержит количество вершин n (1 ≤ n ≤ 105) в дереве. Каждая из следующих n - 1 строк содержит два числа u и v (1 ≤ u, v ≤ n), задающих ребро в дереве. Последняя строка содержит n целых неотрицательных чисел c1, ... cn - количество монет в вершинах дерева.\nВыходные данные\nВывести максимально возможную сумму монет в выбранном подмножестве вершин дерева.", "compiler": "Judge C++", "send_date": "25 июн. 2017 г., 20:33:00", "time": 163.28, "memory": 39672, "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <int> g[(int)1e6];\nvector <int> c(1e6);\nlong long sum = 0;\nvector <int> dp1(1e6);\nvector <int> dp2(1e6);\nvector <bool> used(1e6);\ninline void dfs(int v, int parent = -1){\n    dp1[v] = c[v];\n    dp2[v] = 0;\n    for(int i = 0 ; i < g[v].size();i++){\n        if(g[v][i] != parent){\n            dfs(g[v][i],v);\n            dp1[v] += dp2[g[v][i]];\n            dp2[v] += max(dp1[g[v][i]],dp2[g[v][i]]);\n        }\n    }\n}\nint main()\n{\n    int n;\n    cin >> n;\n    int a,b;\n    used.assign(n+1,false);\n    dp1.resize(n+1);\n    dp2.resize(n+1);\n    for(int i = 0; i < n-1; i++)\n    {\n        cin >> a >> b;\n        a--;\n        b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    for(int i = 0; i < n; i++)\n        cin >> c[i];\n    dfs(0);\n    sum = max(dp1[0],dp2[0]);\n    cout <<sum << endl;\n\n}", "link": "https://www.e-olymp.com/ru/problems/973"}