{"name": "Дима и массив", "text": "Дима и массив\nМама подарила мальчику Диме массив длины n. Массив этот не простой, а особенный. Дима может выбрать два числа i и d (1 ≤ i ≤ n, -1000 ≤ d ≤ 1000), и элемент с индексом i магически становится равным d. Дима играет со своим массивом, а мама время от времени задает ему вопросы - какова сумма всех чисел в массиве с индексами от f до t? Дима легко справился с этими вопросами, сможете ли Вы?\nВходные данные\nВ первой строке находятся два целых числа n и q (1 ≤ n ≤ 5 *105, 1 ≤ q ≤ 105) - количество элементов в массиве и суммарное количество операций и запросов соответственно. В следующей строке дано n чисел a1, a2, ..., an (-1000 ≤ ai ≤ 1000) - начальное состояние массива. В следующих q строках заданы операции и запросы. Первый символ в строке может быть = или ?. Если строка начинается с =, то это операция присваивания. Далее следуют i и d, ограничения на которые описаны в условии. Если строка начинается с ?, то это запрос. Далее следуют числа f и t (1 ≤ f, t ≤ n).\nВыходные данные\nДля каждого запроса выведите сумму чисел в массиве с индексами от f до t, по одному результату в строке.", "compiler": "Judge C++", "send_date": "24 июн. 2017 г., 20:11:05", "time": 352.69, "memory": 9048, "code": "#include <bits/stdc++.h>\nusing namespace std;\nint *A, *tree;\nint query(int k, int left, int right, int l, int r){\n    if(l > r)\n        return 0;\n    if(l == left && r == right)\n        return tree[k];\n    int center = (left + right)/2;\n    return query(2*k,left,center,l,min(r,center))+\n            query(2*k + 1, center+1,right,max(l,center+1),r);\n}\nvoid build(int k, int left, int right){\n    if(left == right){\n        tree[k] = A[left];\n        return;\n    }\n    int center = (left + right)/2;\n\n    build(2*k,left,center);\n    build(2*k+1,center+1,right);\n    tree[k] = tree[2*k] + tree[2*k + 1];\n}\nvoid update(int k, int l, int r, int i, int value){\n    if(r == l){\n        tree[k] = value;\n        return;\n    }\n    int center = (r + l)/2;\n    if(i <= center)\n        update(2*k,l,center,i,value);\n    else\n        update(2*k+1,center+1,r,i,value);\n    tree[k] = tree[k*2] + tree[k*2 + 1];\n}\nint main() {\n    int n,q,l,r;\n    char t;\n    cin >> n >> q;\n    A = new int[n];\n    tree = new int[4 * n];\n    for(int i = 0; i < n; i++)\n        cin >> A[i];\n    build(1,0,n-1);\n    while(q--){\n        int i,d;\n        cin >> t;\n        if(t == '?'){\n            cin >> l >> r;\n            cout << query(1,0,n-1,--l,--r) << endl;\n        }else{\n            cin >> i >> d;\n            i--;\n            update(1,0,n-1,i,d);\n        }\n    }\n}", "link": "https://www.e-olymp.com/ru/problems/2941"}