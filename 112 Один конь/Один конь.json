{"name": "Один конь", "text": "Один конь\nНа шахматной доске n × n в клетке (x1, y1) стоит голодный шахматный конь. Он хочет попасть в клетку (x2, y2), где растет вкусная шахматная трава. Какое наименьшее количество ходов он должен для этого сделать?\nВходные данные\nСодержит пять чисел: n, x1, y1, x2, y2 (5 ≤ n ≤ 20, 1 ≤ x1, y1, x2, y2 ≤ n). Левая верхняя клетка доски имеет координаты (1, 1), правая нижняя - (n, n).\nВыходные данные\nВывести наименьшее количество ходов коня, за которое можно попасть из (x1, y1) в (x2, y2).", "compiler": "Judge C++", "send_date": "15 окт. 2017 г., 16:14:25", "time": 2.18, "memory": 1760, "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector < pair<int,int> > g[501];\nint d[501][501];\nqueue< pair<int,int> > q;\nvoid bfs(pair<int,int> s, pair<int,int> f, int n){\n    d[s.first][s.second] = 1;\n    //d[s] = 1;\n    q.push(s);\n    int dx[8] = {2, 2, 1, 1, -1, -1, -2, -2};\n    int dy[8] = {1, -1, 2, -2, 2, -2, 1, -1};\n    bool c = false;\n    while(!q.empty()){\n        pair<int,int> v = q.front();\n        q.pop();\n        int x = v.first,y = v.second;\n        pair<int,int> to;\n        for(int i = 0; i < 8; i++){\n            x += dx[i];\n            y += dy[i];\n            to = {x,y};\n            if((x <= n && x >= 1) && (y <= n && y >= 1) && !d[x][y]){\n                q.push(to);\n                d[x][y] = d[v.first][v.second] + 1;\n                if(f == to) {\n                    cout << d[x][y]-1 << endl;\n                    return;\n                }\n            }\n            x -= dx[i];\n            y -= dy[i];\n        }\n    }\n}\nint main()\n{\n    int n;\n    cin >> n;\n    int d[n][n];\n    int x1,y1,x2,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    pair<int,int> one(x1,y1), two(x2,y2);\n    bfs(one,two, n);\n}", "link": "https://www.e-olymp.com/ru/problems/997"}