{"name": "Winter", "text": "Winter\nКраїна Ужляндія славиться своїми ідеальними дорогами, але навіть вони не витримали цьогорічної аномально холодної та сніжної зими. Деякі з доріг виявилися заблокованими для руху автомобілістів. Внаслідок цього порушився зв’язок між містами Ужляндії. Два міста країни вважаються з’єднаними, якщо можна дістатися з одного міста в інше, рухаючись не заблокованими дорогами, можливо, через інші міста.\nСусідня братська держава відома на весь світ своїми унікальними обігрівачами. Керівництво країни вирішило надати Ужляндії гуманітарну допомогу. Було вирішено, що обігрівачі доставлятимуться на гвинтокрилі, а далі за допомогою вантажівок розвозитимуться по містах. Оскільки авіаційне паливо не дешеве, потрібно мінімізувати кількість приземлень гвинтокрила так, щоби кожне місто отримало необхідні обігрівачі. Будь ласка, якомога швидше порахуйте цю кількість і врятуйте мешканців Ужляндії.\nФормат вхідних даних: В першому рядку записано два числа N і M (1 ≤ N ≤ 100000,0 ≤ M ≤ 200000) – кількість міст в Ужляндії та кількість не заблокованих доріг відповідно. В наступних M рядках записано по два числа i та j (1 ≤ i,j ≤ N), що значить дорога між містами з номерами i та j не заблокована. Міста в Ужляндії нумеруються в 1 до N.\nФормат вихідних даних: В єдиному рядку виведіть мінімальну кількість приземлень гвинтокрила.\nПояснення до прикладу:\nМіста 1, 2 та 3 з’єднані між собою, а тому щоби забезпечити їх обігрівачами, необхідно здійснити одне приземлення в одному з цих міст, далі обігрівачі доставлять вантажівками. Міста 4 та 5 зв’язані між собою, тому треба ще одне приземлення. І нарешті місто 6, яке ізольоване від інших, щоби доставити обігрівачі в це місто, треба окреме приземлення гвинтокрила. Всього виходить 3 приземлення.", "compiler": "Judge C++", "send_date": "30 янв. 2017 г., 19:15:04", "time": 52.91, "memory": 6464, "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <int> G[100001];\nvector <bool> used(100001,false);\nint n, m;\nvoid dfs(int v)\n{\n    used[v] = true;\n    for(int p = 0; p < G[v].size();p++)\n    {\n        if(!used[G[v][p]])\n        {\n            dfs(G[v][p]);\n        }\n    }\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int i,j,a,b;\n    int k = 0;\n    cin >> n >> m;\n    if(m ==0)\n    {\n        cout << n << endl;\n        return 0;\n    }\n    for(i = 0;i < m;i++)\n    {\n        cin >> a >> b;\n        G[a-1].push_back(b-1);\n        G[b-1].push_back(a-1);\n    }\n    for(i=0;i<n;i++)\n    {\n        if(used[i] == false){\n            dfs(i);\n            k++;\n        }\n    }\n    cout << k << endl;\n\n}", "link": "https://www.e-olymp.com/ru/problems/7236"}