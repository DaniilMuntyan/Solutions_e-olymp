{"name": "Числа", "text": "Числа\nВитя хочет придумать новую игру с числами. В этой игре от игроков требуется преобразовать четырёхзначные числа, не содержащие нулей, при помощи следующего разрешённого набора действий:\nМожно увеличить первую цифру числа на 1, если она не равна 9.\nМожно уменьшить последнюю цифру на 1, если она не равна 1.\nМожно циклически сдвинуть все цифры на одну вправо.\nМожно циклически сдвинуть все цифры на одну влево.\nНапример, применяя эти правила к числу 1234 можно получить числа 2234, 1233, 4123 и 2341 соответственно. Точные правила игры Витя пока не придумал, но пока его интересует вопрос, как получить из одного числа другое за минимальное количество операций.\nВходные данные\nДва различных четырёхзначных числа, каждое из которых не содержит нулей.\nВыходные данные\nВывести последовательность четырёхзначных чисел, не содержащих нулей. Последовательность должна начинаться первым из заданных чисел и заканчиваться вторым из данных чисел, каждое последующее число в последовательности должно быть получено из предыдущего числа применением одного из правил. Количество чисел в последовательности должно быть минимально возможным.", "compiler": "Judge C++", "send_date": "15 окт. 2017 г., 16:39:57", "time": 3.08, "memory": 1796, "code": "#include <bits/stdc++.h>\nusing namespace std;\nint s,f;\nvector <int> p(10001,-1);\nvector <int> used(10001,0);\nqueue <int> q;\nint sdR(int a)\n{\n    int t,s,d,e;\n    e = a%10;\n    a/=10;\n    d = a%10;\n    a/=10;\n    s = a%10;\n    a /=10;\n    t = a%10;\n    return (e*1000 + t*100 + s*10 + d);\n}\nint sdL(int a)\n{\n    int t,s,d,e;\n    e = a%10;\n    a/=10;\n    d = a%10;\n    a/=10;\n    s = a%10;\n    a /=10;\n    t = a%10;\n    return (s*1000 + d*100 + e*10 + t);\n}\nvoid bfs(int k)\n{\n    q.push(k);\n    used[k] = -1;\n    while(!q.empty())\n    {\n        k = q.front();\n        q.pop();\n        if(k==f)\n            return;\n        if(k + 1000 < 10000 && !used[k+1000])\n        {\n            used[k+1000] = k;\n            q.push(k+1000);\n        }\n        if((k%10)!=1 && !used[k-1])\n        {\n            used[k-1] = k;\n            q.push(k-1);\n        }\n        if(!used[sdR(k)])\n        {\n            used[sdR(k)] = k;\n            q.push(sdR(k));\n        }\n        if(!used[sdL(k)])\n        {\n            used[sdL(k)] = k;\n            q.push(sdL(k));\n        }\n    }\n}\nint main()\n{\n    cin >> s >> f;\n    bfs(s);\n    vector <int> ans;\n    ans.push_back(f);\n    while(f != s)\n    {\n        ans.push_back(used[f]);\n        f = used[f];\n    }\n    reverse(ans.begin(),ans.end());\n    for(int i = 0; i < ans.size();i++)\n    {\n        cout << ans[i] << endl;\n    }\n}", "link": "https://www.e-olymp.com/ru/problems/4007"}