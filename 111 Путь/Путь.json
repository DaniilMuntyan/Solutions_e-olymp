{"name": "Путь", "text": "Путь\nВ неориентированном графе требуется найти минимальный путь между двумя вершинами.\nВходные данные\nВо входном файле записано сначала число N - количество вершин в графе (1 ≤ N ≤ 100). Затем записана матрица смежности (0 обозначает отсутствие ребра, 1 - наличие ребра). Затем записаны номера двух вершин - начальной и конечной.\nВыходные данные\nВ выходной вывести файл L - длину кратчайшего пути (количество ребер, которые нужно пройти). Если пути не существует, выведите одно число -1.", "compiler": "Judge C++", "send_date": "15 окт. 2017 г., 14:52:20", "time": 4.23, "memory": 1752, "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, s, f,i,j,c;\nvector <int> g[150];\nvector <int> d(150);\nqueue <int> q;\nvoid BFS(int s,int f)\n{\n    d[s]=1;\n    q.push(s);\n    while(!q.empty())\n    {\n        int k = q.front();\n        q.pop();\n        for(i=0;i<g[k].size();i++)\n        {\n            if(!d[g[k][i]])\n            {\n                q.push(g[k][i]);\n                d[g[k][i]] = d[k]+1;\n                if(g[k][i]==f)\n                    return;\n            }\n        }\n    }\n}\nint main()\n{\n    int a;\n    cin >> n;\n    for(i=1;i<=n;i++)\n    {\n        for(j=1;j<=n;j++)\n        {\n            cin >> a;\n            if(a)\n                g[i].push_back(j);\n\n        }\n    }\n    cin >> s >> f;\n    if(s > f) swap(s,f);\n    BFS(s,f);\n    if(d[f])\n    cout << d[f]-1 << endl;\n    else\n        cout << -1 << endl;\n}", "link": "https://www.e-olymp.com/ru/problems/996"}