{"name": "Обход в глубину", "text": "Обход в глубину\nДан неориентированный невзвешенный граф, в котором выделена вершина. Вам необходимо найти количество вершин, лежащих с ней в одной компоненте связности (включая саму вершину).\nВходные данные\nВ первой строке содержится количество вершин графа n и выделенная вершина s (1 ≤ s ≤ n ≤ 100). В следующих n строках записано по n чисел - матрица смежности графа, в котрой цифра \"0\" означает отсутствие ребра между вершинами, а цифра \"1\" - его наличие. Гарантируется, что на главной диагонали матрицы всегда стоят нули.\nВыходные данные\nВыведите искомое количество вершин.", "compiler": "Judge C++", "send_date": "15 сент. 2017 г., 23:02:41", "time": 3.75, "memory": 1804, "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nvector <int> g[101];\nvector <bool> used(101, false);\nint k = 1;\nvoid dfs(int v){\n    used[v] = true;\n    //cout << v << \" \" << k <<  endl;\n    for(int i = 0; i < g[v].size();i++)\n    {\n        if(!used[g[v][i]]){\n            k++;\n            dfs(g[v][i]);\n        }\n    }\n}\nmain()\n{\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    int n, s;\n    int a;\n    cin >> n >> s;\n    --s;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            cin >> a;\n            if(a == 1){\n                g[i].push_back(j);\n                g[j].push_back(i);\n            }\n        }\n    }\n    dfs(s);\n    cout << k << endl;\n}", "link": "https://www.e-olymp.com/ru/problems/4000"}