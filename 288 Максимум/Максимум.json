{"name": "Максимум", "text": "Максимум\nВаша задача очень простая и даже без большой легенды: просто нужно найти максимум на отрезке.\nВходные данные\nСначала подаётся количество чисел n (1 ≤ n ≤ 105) в массиве. В следующей строке заданы n чисел – исходный массив a1, a2, ..., an (-109 ≤ ai ≤ 109). Следующая строка содержит количество запросов q (1 ≤ q ≤ 5·105). Каждая из следующих q строк содержит по два натуральных числа l и r (1 ≤ l, r ≤ n) – отрезок, на котором следует найти максимум.\nВыходные данные\nДля каждого запроса выведите максимум на заданном отрезке.", "compiler": "Judge C++", "send_date": "25 июн. 2017 г., 7:56:15", "time": 957.86, "memory": 4996, "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long *A, *tree;\ninline void build(int k, int left, int right){\n    if(left == right){\n        tree[k] = A[left];\n        return;\n    }\n    int center = (left + right)/2;\n    build(2*k,left, center);\n    build(2*k+1,center+1,right);\n    tree[k] = max(tree[k*2],tree[k*2 + 1]);\n}\ninline int query(int k, int left, int right, int l, int r){\n    if(l > r)\n        return INT_MIN;\n    if(left == l && right == r)\n        return tree[k];\n    int center = (right + left)/2;\n    return max(query(k*2,left,center,l,min(r,center)),\n               query(k*2 + 1,center+1,right,max(l,center+1),r));\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n,q;\n    cin >> n;\n    A = new long long[n];\n    tree = new long long[4 * n];\n    for(register int i = 0; i < n; i++)\n        cin >> A[i];\n    cin >> q;\n    build(1,0,n-1);\n    int l,r;\n    for(int i = 0; i < q; ++i){\n        cin >> l >> r;\n        if(l > r)\n            swap(l,r);\n        cout << query(1,0,n-1,--l,--r) << endl;\n    }\n}", "link": "https://www.e-olymp.com/ru/problems/4473"}