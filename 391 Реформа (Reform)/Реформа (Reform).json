{"name": "Реформа (Reform)", "text": "Реформа (Reform)\nВсе знают насколько сложный руогский язык - слова очень длинные, буквы могут повторяться несколько раз. Поэтому по инициативе Академии руогских наук предложена реформа языка, которая предусматривает, что каждое слово преобразуется по следующим правилам:\nоно состоит из тех же букв, что и исходное;\nкаждая буква в новом слове будет встречаться только один раз;\nбуквы будут упорядочены в алфавитном порядке;\nесли слово начиналось с большой буквы, то и первая буква нового слова также будет большой.\nВсе знаки препинания и пробелы остаются без изменений. Но возникла проблема в сохранении литературного наследия, которое нужно переписать по новым правилам. Был объявлен международный конкурс на составление программы, которая будет делать это автоматически, и Андрей, конечно, решил принимать в нем участие. А Вы хотите посоревноваться также? Тексты разбиты на строки, длина каждой из них не превышает 1000 символов, они состоят из больших и малых латинских букв, знаков препинания и пробелов. Большая буква может встречаться только в начале слова.\nВходные данные\nПрограмма читает с клавиатуры строку в старой редакции языка..\n\nВыходные данные\nПрограмма выводит на экран эту же строку в новой редакции.", "compiler": "Judge C++", "send_date": "5 дек. 2017 г., 16:10:47", "time": 4.06, "memory": 1792, "code": "#include <bits/stdc++.h>\n \nbool f(char c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n \nusing namespace std;\n \nint main() {\n    string s, ans = \"\";\n    char c;\n    while(cin >> s) {\n        vector<char>a;\n        bool k = s[0] >= 'A' && s[0] <= 'Z';\n        if (k)\n        {\n            s[0] = tolower(s[0]);\n        }\n        for (int i = 0; i < s.size(); i++)\n        {\n            if (!f(s[i]))\n            {\n                ans+=s[i];\n                continue;\n            }\n            a.push_back(s[i]);\n            while(++i < s.size() && (f(s[i-1]) == f(s[i])))\n            {\n                a.push_back(s[i]);\n            }\n            i--;\n            int j = i;\n            sort(a.begin(), a.end());\n            if (k) {\n                a[0] += 'A' - 'a';\n            }\n            ans+=a[0];\n            for (int i = 1; i < a.size(); i++)\n            {\n                if (a[i] != a[i-1] && a[i] != a[i-1] - 'A' + 'a')\n                {\n                    ans+=a[i];\n                }\n            }\n            i = j;\n            a.clear();\n        }\n    ans += \" \";\n    }\n    cout << ans << endl;\n    return 0;\n}", "link": "https://www.e-olymp.com/ru/problems/7372"}