{"name": "Дейкстра", "text": "Дейкстра\nДан ориентированный взвешенный граф. Найдите кратчайшее расстояние от одной заданной вершины до другой.\nВходные данные\nВ первой строке содержится три числа n, s и f (1 ≤ n ≤ 2000; 1 ≤ s, f ≤ n), где n - количество вершин графа, s - начальная вершина, а f - конечная. В следующих n строках по n чисел - матрица смежности графа, где -1 означает отсутствие ребра между вершинами, а любое неотрицательное число - присутствие ребра данного веса. На главной диагонали матрицы всегда записаны нули.\nВыходные данные\nВывести искомое расстояние или -1, если пути не существует.", "compiler": "Judge C++", "send_date": "3 февр. 2017 г., 15:32:48", "time": 133.01, "memory": 1772, "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long m = 1000000000;\nint main()\n{\n    int n,s,f;\n    cin >> n >> s >> f;\n    vector < pair<int,int> > g[n+1];\n    vector <int> d(n+1,m);\n    set < pair <int,int> > q;\n    s--;\n    f--;\n    int i,j,a;\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<n;j++)\n        {\n            cin >> a;\n            if(a!=-1 && a)\n                g[i].push_back({a,j});\n\n        }\n    }\n    d[s] = 0;\n    q.insert({0,s});\n    while(!q.empty())\n    {\n        int v = q.begin() -> second;\n        q.erase(q.begin());\n        for(i=0;i<g[v].size();i++)\n        {\n            int to = g[v][i].second;\n            int l = g[v][i].first;\n            if(d[v] + l < d[to])\n            {\n                d[to] = d[v] + l;\n                q.insert({d[to],to});\n            }\n        }\n    }\n\n    if(d[f] < m)\n        cout << d[f] << endl;\n    else\n        cout << -1 << endl;\n}", "link": "https://www.e-olymp.com/ru/problems/2351"}