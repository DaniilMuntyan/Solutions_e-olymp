{"name": "Объединение отрезков", "text": "Объединение отрезков\nРешая задачу из контрольной по математике, Вася получил ответ в виде объединения n отрезков [li, ri] на числовой прямой. Однако, некоторые из этих отрезков могут пересекаться друг с другом, что не слишком нравится Васе.\nВаша задача - представить Васин ответ в виде объединения минимального количества отрезков.\nВходные данные\nВ первой строке указано число n (1 ≤ n ≤ 50000). В следующих n строках перечислены пары целых чисел li и ri (|li|, |ri| ≤ 50000), каждая пара с новой строки, числа в парах отделены друг от друга одним или несколькими пробелами.\nВыходные данные\nВ первой строке выведите число m - количество отрезков в искомом объединении. В следующих m строках выведите сами эти отрезки в том же формате, что и на входе. Список отрезков необходимо упорядочить по возрастанию левого конца.", "compiler": "Judge C++", "send_date": "6 сент. 2017 г., 22:54:47", "time": 53.48, "memory": 3196, "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct S{\n    int x, typ;\n};\nmain() {\n    int n;\n    cin >> n;\n    vector <S> a;\n    vector < pair<int,int> > ans;\n    int s, f;\n  //  cout << endl;\n    for(int i = 0; i < n; i++){\n        cin >> s >> f;\n        S p;\n        p.x = s; p.typ = 1;\n      //  cout << \"add: \" << p.x << \" \" << p.typ << endl;\n        a.push_back(p);\n        p.x = f; p.typ = -1;\n      //  cout << \"add: \" << p.x << \" \" << p.typ << endl;\n        a.push_back(p);\n    }\n  //  cout << endl;\n    struct{\n        bool operator()(S a, S b)const\n        {\n            if(a.x < b.x) return true;\n            if(a.x == b.x) return a.typ > b.typ;\n            return false;\n        }\n    }comparator;\n    sort(a.begin(), a.end(), comparator);\n    int cnt = 0;\n    int start = 0, finish = 0;\n    bool check = false;\n  /*  for(int i = 0; i < a.size(); i++){\n        cout << a[i].x << \" \" << a[i].typ << endl;\n    }*/\n    for(int i = 0; i < a.size(); i++){\n        if(cnt == 0 && (cnt+a[i].typ) != 0)\n            start = a[i].x;\n        if(cnt != 0 && (cnt+a[i].typ)==0){\n            finish = a[i].x;\n            ans.push_back({start, finish});\n        }\n        cnt += a[i].typ;\n    }\n    cout << ans.size() << endl;\n    for(int i = 0; i < ans.size();i++)\n        cout << ans[i].first << \" \" << ans[i].second << endl;\n}", "link": "https://www.e-olymp.com/ru/problems/4424"}