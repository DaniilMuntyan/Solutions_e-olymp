{"name": "Подземелье", "text": "Подземелье\nВы попали в 3D подземный лабиринт и необходимо найти быстрый выход! Карта подземелья составлена из единичных кубических комнат, по которым можно или нельзя передвигаться. Нужно всего одну минуту, чтобы переместиться она одну единицу на север, юг, восток, запад, вверх или вниз. Вы не можете двигаться по диагонали, и лабиринт окружен твердой скальной породой со всех сторон.\nМожно ли выбраться из лабиринта? Если да, то какое времени это займет?\nВходные данные\nСостоит из ряда подземелий. Каждое описание подземелья начинается со строки, содержащей три целых числа: количество уровней в подземелье l, а также r и c - количество строк и столбцов, описывающих план каждого уровня (все числа не больше 30).\nДалее следует l блоков по r строк, каждая по c символов. Каждое число описывает одну ячейку подземелья. Запрещенные для перемещения кубы подземелья обозначены символом '#', а пустые клетки обозначены '.'. Ваша стартовая позиция обозначается буквой 'S', а выход буквой 'Е'. Все описания подземелий отделены пустой строкой. Описание входных данных заканчивается тремя нулями.\nВыходные данные\nДля каждого лабиринта необходимо вывести одну строку. Если есть возможность добраться до выхода, вывести строку вида\n\nEscaped in X minute(s).\nгде X - наименьшее время, необходимое для достижения выхода.\nЕсли достичь выход невозможно, вывести строку\nTrapped!", "compiler": "Judge C++", "send_date": "16 окт. 2017 г., 0:35:33", "time": 7.33, "memory": 1740, "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct S{\n    int k, i, j;\n    S(int a, int b, int c){\n        k = a;\n        i = b;\n        j = c;\n    }\n    S(){}\n    bool operator ==(S b)const{\n        return (this->k==b.k && this->i == b.i && this->j == b.j);\n    }\n};\nint si, sj, sl, ei,ej,el;\nint l,r,c;\nchar t[31][31][31];\nS stop(el,ei,ej);\nqueue<S> q;\nint d[31][31][31];\nbool check(int k, int i, int j){\n    return ((k >= 1 && k <= l) && (i >= 1 &&\n            i <= r) && (j >= 1 && j <= c));\n}\nvoid bfs(int k, int i, int j){\n    while(!q.empty()) q.pop();\n    stop = S(el,ei,ej);\n    d[k][i][j] = 1;\n    q.push(S(k,i,j));\n    int dk[] = {0, 0, 0, 0, -1, 1};\n    int dx[] = {1, 0, -1, 0, 0, 0};\n    int dy[] = {0, -1, 0, 1, 0, 0};\n    while(!q.empty()){\n        S v = q.front();\n        q.pop();\n        k = v.k;\n        i = v.i;\n        j = v.j;\n        for(int kC = 0; kC < 6; kC++){\n            k += dk[kC];\n            i += dx[kC];\n            j += dy[kC];\n            if(check(k,i,j) && (t[k][i][j] != '#') && !d[k][i][j]){\n                q.push(S(k,i,j));\n                d[k][i][j] = d[v.k][v.i][v.j] + 1;\n                if((k == stop.k && i == stop.i && j == stop.j) || t[k][i][j] == 'E'){\n                    if(d[k][i][j]-1 >= 0)\n                    cout << \"Escaped in \" << d[k][i][j]-1  <<\" minute(s).\" << endl;\n                    else cout << \"Trapped!\" << endl;\n                    return;\n                }\n            }\n\n            k -= dk[kC];\n            i -= dx[kC];\n            j -= dy[kC];\n        }\n    }\n    cout << \"Trapped!\" << endl;\n}\nmain()\n{\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    char a;\n    while(cin >> l >> r >> c){\n        if(l == 0 && r == 0 && c == 0)\n        return 0;\n        for(int k = 1; k <= l; k++){\n            for(int i = 1; i <= r; i++){\n                for(int j = 1; j <= c; j++){\n                    cin >> t[k][i][j];\n                    d[k][i][j] = 0;\n                    if(t[k][i][j] == 'S'){\n                        si = i;\n                        sj = j;\n                        sl = k;\n                    }\n                    if(t[k][i][j] == 'E'){\n                        ei = i;\n                        ej = j;\n                        el = k;\n                    }\n                }\n            }\n        }\n        bfs(sl,si,sj);\n    }\n}", "link": "https://www.e-olymp.com/ru/problems/432"}