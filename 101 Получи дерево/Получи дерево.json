{"name": "Получи дерево", "text": "Получи дерево\nДан связный неориентированный граф без петель и кратных ребер. Разрешается удалять из него ребра. Требуется получить дерево.\nВходные данные\nПервая строка содержит количество вершин n (1 ≤ n ≤ 100) и количество ребер m графа. Следующие m пар чисел задают ребра графа. Гарантируется, что граф связный.\nВыходные данные\nВыведите n - 1 пару чисел - ребра, которые войдут в дерево. Ребра можно выводить в любом порядке.", "compiler": "Judge C++", "send_date": "19 сент. 2017 г., 15:10:17", "time": 1.86, "memory": 1748, "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n \n \nstruct edge{\n    int x, y; \n    edge(){}\n    edge(int a, int b){\n        x = a;\n        y = b;\n    }\n};\n \nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector <edge> graph (m);\n    vector <edge> tree; \n    vector <int> variety (n);\n    \n   \n    for (int i = 0; i < n; i++){\n        variety[i] = i;\n    }\n    \n   \n    for (int i = 0; i < m; i++){\n        int a, b;\n        cin >> a >> b;\n        graph[i].x = a;\n        graph[i].y = b;\n    }\n    \n    \n    for (int i = 0; i < m; i++){\n        int a = graph[i].x;\n        int b = graph[i].y;\n        if (variety[a] != variety[b]){\n            tree.push_back(graph[i]);\n            int old_variety = variety[b], new_variety = variety[a];\n            for (int j = 0; j < n; j++){\n                if (variety[j] == old_variety){\n                    variety[j] = new_variety;\n                }\n            }\n            \n            \n            \n        }\n    }\n \n    \n    for(int i = 0; i < n - 1; i++){\n        cout << tree[i].x << \" \" << tree[i].y;\n        if (i != n-2){\n            cout << endl;\n        }\n    }\n    return 0;\n}", "link": "https://www.e-olymp.com/ru/problems/978"}