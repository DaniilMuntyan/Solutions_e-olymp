{"name": "Обход в ширину", "text": "Обход в ширину\nДан неориентированный граф. В нём необходимо найти расстояние от одной заданной вершины до другой.\nВходные данные\nВ первой строке содержится три натуральных числа n, s и f (1 ≤ s, f ≤ n ≤ 100) - количество вершин в графе и номера начальной и конечной вершин соответственно. Далее в n строках задана матрица смежности графа. Если значение в j-м элементе i-й строки равно 1, то в графе есть направленное ребро из вершины i в вершину j.\nВыходные данные\nВывести минимальное расстояние от начальной вершины до конечной. Если пути не существует, выведите 0.", "compiler": "Judge C++", "send_date": "15 окт. 2017 г., 16:15:24", "time": 5.46, "memory": 1804, "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, s, f,i,j,c;\nvector <int> used(101);\nvector <int> g[101];\nvector <int> d(101);\nqueue <int> q;\nvoid BFS(int s,int f)\n{\n    d[s]=1;\n    q.push(s);\n    while(!q.empty())\n    {\n        int k = q.front();\n        q.pop();\n        for(i=0;i<g[k].size();i++)\n        {\n            if(!d[g[k][i]])\n            {\n                q.push(g[k][i]);\n                d[g[k][i]] = d[k]+1;\n                if(g[k][i]==f)\n                    return;\n            }\n        }\n    }\n}\nint main()\n{\n    int a;\n    cin >> n >> s >> f;\n    for(i=1;i<=n;i++)\n    {\n        for(j=1;j<=n;j++)\n        {\n            cin >> a;\n            if(a)\n                g[i].push_back(j);\n        }\n    }\n    BFS(s,f);\n    if(d[f])\n    cout << d[f]-1 << endl;\n    else\n        cout << 0 << endl;\n}", "link": "https://www.e-olymp.com/ru/problems/2401"}