{"name": "Безопасный полет", "text": "Безопасный полет\nВ настоящее время из-за сокращения бюджета даже шпионы должны использовать коммерческие авиакомпании для путешествия между городами в мире. Хотя этот режим поездок может быть и очень удобным для шпиона, однако также создает проблему: шпион должен доверять пилоту - то есть убедиться, что он не находится в опасности во время полета. И даже хуже: иногда нет прямого рейса между некоторыми парами городов, так что шпион должен лететь несколькими рейсами, чтобы добраться до нужного места, вследствие чего он должен доверять нескольким пилотам!\nДля ограничения вопросов доверия Вы обратились за помощью. По имеющемуся расписанию полетов следует найти наименьший набор пилотов, которым следует доверять чтобы шпион мог безопасно путешествовать между всеми городами.\nВходные данные\nПервая строка содержит количество тестов, которое не больше 100. Далее для каждого теста:\nв одной строке содержится количество городов n (2 ≤ n ≤ 1000) и пилотов m (1 ≤ m ≤ 10000).\nm строк с числами a и b (1 ≤ a, b ≤ n, a ≠ b): пилот летает между городами a и b туда и обратно.\nПутешествовать между городами можно пользуясь одним или несколькими перелетами. Граф является связным.\nВыходные данные\nДля каждого теста в отдельной строке вывести наименьшее количество пилотов, которым следует доверять шпиону, чтобы иметь возможность путешествовать между любыми парами городов.", "compiler": "Judge C++", "send_date": "20 июн. 2017 г., 21:15:10", "time": 69.35, "memory": 1740, "code": "#include <bits/stdc++.h>\n#include <string>\nusing namespace std;\nvector <int> g[1001];\nint k = 0;\nvector <bool> used(1001,false);\nvoid dfs(int v){\n    used[v] = true;\n    for(int i = 0; i < g[v].size();i++){\n        if(!used[g[v][i]]){\n            k++;\n            dfs(g[v][i]);\n        }\n    }\n}\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        int n,m,a,b;\n        cin >> n >> m;\n        for(int i = 0; i < m;i++)\n        {\n            cin >> a >> b;\n            g[a-1].push_back(b-1);\n            g[b-1].push_back(a-1);\n        }\n        dfs(0);\n        cout << k << endl;\n        k = 0;\n        for(int i = 0; i < n; i++)\n            g[i].clear();\n        used.assign(1001,false);\n    }\n}", "link": "https://www.e-olymp.com/ru/problems/6422"}