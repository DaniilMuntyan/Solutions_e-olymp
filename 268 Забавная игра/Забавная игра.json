{"name": "Забавная игра", "text": "Забавная игра\nВ одной стране есть несколько аэропортов, между некоторыми аэропортами есть рейсы. Можно перелететь из любого аэропорта в любой другой, возможно, с несколькими пересадками. Для каждой пары аэропортов существует только одна последовательность рейсов, соединяющая эти аэропорты.\nДва террориста играют в игру. Они делают ходы по очереди. Каждый ход заключается в следующих действиях. Игрок минирует аэропорт, выбирает рейс и улетает вместе со своим коллегой. После взлёта он активирует радиоуправляемый взрыватель. В результате аэропорт, который только что покинули террористы, разрушен, и рейсы в этот аэропорт и из него больше невозможны. После того, как самолёт приземляется, другой игрок делает ход — и дальше по очереди. Проигрывает тот, кто не может сделать ход.\nНапишите программу, которая по начальному списку полётов и номеру аэропорта, в котором террористы начинают игру, определяет, кто выигрывает, если террористы играют идеально (каждый выбирает лучший ход).\nВходные данные\nПервая строка содержит два целых числа: n и k, разделённые пробелом. Здесь n — количество аэропортов (n ≤1000), а k — номер аэропорта, являющегося начальной точкой игры (1 ≤ k ≤ n). Следующая n−1 строка содержит пары целых чисел, разделённых пробелами. Это номера аэропортов, соединённых рейсом. Все рейсы двусторонние и упомянуты только один раз. Каждый аэропорт соединён рейсами не более, чем с 20 другими.\nВыходные данные\nЕсли игрок, начинающий игру, выигрывает, программа должна написать \"First player wins flying to airport L\", где L— номер аэропорта, в который игрок должен вылететь из текущего. Если таких аэропортов несколько, программа должна выбрать вариант с меньшим номером аэропорта. Если начинающий игрок проигрывает, программа должна написать \"First player loses\".", "compiler": "Judge C++", "send_date": "26 июн. 2017 г., 12:18:33", "time": 5.77, "memory": 1748, "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <int> g[(int)1e4];\nvector <int> state(1e4);\nint k;\nint x,ans=-1;\n    int m = 1e6;\ninline void dfs(int v, int p = -1){\n\n    state[v] = 0;\n    for(int i = 0; i < g[v].size();i++){\n        int to = g[v][i];\n        if(to == p)\n            continue;\n        dfs(to,v);\n        if(state[to] == 0){\n            state[v] = 1;\n            if(v == k)\n                m = min(m,to);\n        }\n\n    }\n}\nint main()\n{\n    int n,a,b;\n    cin >> n >> k;\n    k--;\n    state.resize(n);\n    for(int i = 0; i < n-1; i++)\n    {\n        cin >> a >> b;\n        a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs(k);\n    if(state[k] == 0)\n        cout << \"First player loses\" << endl;\n    else\n        cout << \"First player wins flying to airport \" << m+1 << endl;\n\n\n}", "link": "https://www.e-olymp.com/ru/problems/4050"}