{"name": "Обратный обход дерева", "text": "Обратный обход дерева\nЗадан массив целых чисел. Создайте из них Бинарное Дерево Поиска. Если вставляемое значение равно текущей вершине, то его следует вставлять в правое поддерево.\nРеализуйте метод PostOrder обратного обхода дерева. При обратном обходе сначала посещается левое поддерево, потом правое поддерево, потом корень.\nНапишите код согласно следующего интерфейса:\nclass TreeNode\n{\npublic:\nint val;\nTreeNode *left;\nTreeNode *right;\nTreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nclass Tree\n{\npublic:\nTreeNode *head;\nTree() : head(NULL) {};\nvoid Insert(int val); // Вставка числа val в Бинарное Дерево Поиска\nvoid PostOrder(void); // Вывести вершины дерева в порядке обратного обхода\n};\nВы можете создавать (использовать) по необходимости дополнительные методы.\nВходные данные\nПервая строка содержит число n (1 ≤ n ≤ 100). Вторая строка содержит n целых чисел.\nВыходные данные\nСоздайте Бинарное Дерево Поиска из входных данных. Выведите вершины дерева в порядке обратного обхода.", "compiler": "Judge C++", "send_date": "23 авг. 2016 г., 20:05:47", "time": 934.71, "memory": 9268, "code": "#include <bits/stdc++.h>\nusing namespace std;\nint a[2000000];\nint c[2000000];\nint main()\n{\n    int n;//количество элементов в массиве\n    int k = 2000000;\n    cin >> n;\n    //считываем массив\n    for(int i = 0; i < n; i++)\n    {\n        cin>>a[i];\n    }\n    //строим массив с\n    for(int i = 0; i < n; i++)\n    {\n        c[a[i]]++;\n    }\n    //бежимся по всему отрезку\n    //с 0 до k-1\n    for(int i = 0; i < k; i++)\n    {\n        //выводим i c[i] раз\n        for(int j = 0; j < c[i]; j++)\n            cout<<i<<\" \";\n    }\n    return 0;\n}", "link": "https://www.e-olymp.com/ru/problems/4038"}