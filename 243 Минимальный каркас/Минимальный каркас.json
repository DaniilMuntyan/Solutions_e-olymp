{"name": "Минимальный каркас", "text": "Минимальный каркас\nТребуется найти в связном графе остовное дерево минимального веса.\nВходные данные\nПервая строка содержит два натуральных числа n и m (1 ≤ n ≤ 20000, 0 ≤ m ≤ 100000) - количество вершин и рёбер графа соответственно. Следующие m строк содержат описания рёбер по одному в строке. Ребро номер i описывается тремя натуральными числами bi, ei и wi (1 ≤ bi, ei ≤ n, 0 ≤ wi ≤ 100000) - номера концов ребра и его вес соответственно.\nГраф является связным.\nВыходные данные\nВыведите единственное целое число - вес минимального остовного дерева.", "compiler": "Judge C++", "send_date": "24 сент. 2017 г., 15:54:58", "time": 107.44, "memory": 3748, "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct E{\n    int a, b, dist;\n};\nvector <E> g(100001);\nvector <int> mas(20001), len(20001);\nint Repr(int n){\n    if(n == mas[n]) return n;\n    return mas[n] = Repr(mas[n]);\n}\nint Union(int x, int y){\n    x = Repr(x);\n    y = Repr(y);\n    if(x == y) return 0;\n    if(len[x] < len[y]) swap(x,y);\n    mas[y] = x;\n    len[x] += len[y];\n    return 1;\n}\nint f(E a, E b){\n    return (a.dist < b.dist);\n}\nmain()\n{\n    int n, m, a, b, c;\n    cin >> n >> m;\n    g.resize(m);\n    len.resize(n);\n    mas.resize(n);\n    for(int i = 0; i < n; i++) mas[i] = i, len[i]=1;\n    for(int i = 0; i < m; i++){\n        cin >> a >> b >> g[i].dist;\n        g[i].a = a;\n        g[i].b = b;\n    }\n    sort(g.begin(), g.end(), f);\n    int res = 0;\n    for(int i = 0; i < m; i++)\n        if(Union(g[i].a, g[i].b))\n            res += g[i].dist;\n    cout << res << endl;\n}", "link": "https://www.e-olymp.com/ru/problems/3835"}