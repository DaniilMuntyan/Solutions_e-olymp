{"name": "Кратчайшее расстояние", "text": "Кратчайшее расстояние\nДан ориентированный граф. Найдите кратчайшее расстояние от вершины x до всех остальных вершин графа.\nВходные данные\nВ первой строке содержатся два натуральных числа n и x (1 ≤ n ≤ 1000, 1 ≤ x ≤ n) - количество вершин в графе и стартовая вершина соответственно. Далее в n строках по n чисел - матрица смежности графа: в i-ой строке на j-ом месте стоит \"1\", если вершины i и j соединены ребром, и \"0\", если ребра между ними нет. На главной диагонали матрицы стоят нули.\nВыходные данные\nВыведите через пробел числа d1, d2, ..., dn, где di равно -1, если путей между x и i нет, в противном случае это минимальное рвсстояние между x и i.", "compiler": "Judge C++", "send_date": "15 окт. 2017 г., 16:38:51", "time": 172.55, "memory": 1800, "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, s, f,i,j,a,m;\nvector <int> g[1001];\nvector <int> d(1001);\nqueue <int> Q;\nvoid BFS(int k)\n{\n d[k] = 1;\n Q.push(k);\n while(!Q.empty())\n {\n  k = Q.front();\n  Q.pop();\n  for(i=0;i<g[k].size();i++)\n   if(!d[g[k][i]])\n   {\n    d[g[k][i]] = d[k] + 1;\n    Q.push(g[k][i]);\n\n   }\n }\n}\nint main()\n{\n cin >> n >> s;\n for(i=1;i<=n;i++)\n  for(j=1;j<=n;j++)\n  {\n   cin >> a;\n   if(a){\n    g[i].push_back(j);\n   }\n  }\n BFS(s);\n for(i=1;i<=n;i++)\n    {\n        if(i!=s)\n        {\n            cout << d[i]-d[s] << \" \";\n        }else\n        cout << 0 << \" \";\n    }\n\n\n}", "link": "https://www.e-olymp.com/ru/problems/4852"}