{"name": "Опасный маршрут", "text": "Опасный маршрут\nВ некотором государстве имеется n городов, некоторые из которых соединены двусторонними дорогами. Города пронумерованы целыми числами от 1 до n. В период финансового кризиса уровень преступности в государстве поднялся и стали появляться организованные преступные группировки. Самой опасной из них стала \"Тимур и его банда\", возглавляемая небезызвестным в криминальных кругах Тимой, которая стала разбойничать на большинстве дорог. В результате по некоторым дорогам стало опасно ездить.\nБахе надо попасть из города 1 в город n. Так как он слишком ценит свою жизнь (и кошелек), он решил обмануть Тиму и поехать по наименее опасному маршруту, пусть даже он будет не самым коротким. Для каждой дороги он определил ее опасность, как целое число от 0 (безопасная) до 1000000 (очень опасная). Опасность маршрута - это максимум из опасностей дорог, составляющих маршрут.\nПомогите ему выбрать самый безопасный маршрут (то есть тот, опасность которого минимально возможная).\nВходные данные\nПервая строка содержит два целых числа n и m (2 ≤ n, m ≤ 1000000). Каждая из следующих m строк определяет одну дорогу и содержит три целых числа:\na, b - города, соединенные дорогой (1 ≤ a, b ≤ n);\nc - опасность дороги (0 ≤ c ≤ 1000000).\nЛюбые два города могут быть соединены несколькими дорогами. Числа в строках разделены пробелами.\nВыходные данные\nОдно целое число - опасность самого безопасного маршрута.", "compiler": "Judge C++", "send_date": "27 сент. 2017 г., 12:38:11", "time": 386.93, "memory": 16316, "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct S{\n    int a,b, dist;\n}g[1000001];\nint mas[1000001];\nint Repr(int n){\n    if(n == mas[n])\n        return n;\n    return mas[n] = Repr(mas[n]);\n}\nint Union(int x, int y){\n    int x1 = Repr(x),y1 = Repr(y);\n    mas[x1] = y1;\n    return (x1 != y1);\n}\nint f(S a, S b)\n{\n  return (a.dist < b.dist);\n}\nint main()\n{\n    int n, m;\n    scanf(\"%d %d\",&n,&m);\n    for(int i = 1; i <= n; i++) mas[i] = i;\n    for(int i = 0; i < m; i++)\n        scanf(\"%d %d %d\",&g[i].a,&g[i].b,&g[i].dist);\n\n    sort(g, g+m, f);\n    int k = -1;\n    for(int i = 0; i < m; i++){\n        Union(g[i].a,g[i].b);\n        k = max(k, g[i].dist);\n        if(Repr(1) == Repr(n)){\n            break;;\n        }\n    }\n    printf(\"%d\\n\", k);\n}", "link": "https://www.e-olymp.com/ru/problems/325"}