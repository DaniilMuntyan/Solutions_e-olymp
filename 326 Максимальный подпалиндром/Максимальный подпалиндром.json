{"name": "Максимальный подпалиндром", "text": "Максимальный подпалиндром\nИз данной строки удалите наименьшее количество символов так, чтобы получился палиндром (строка, одинаково читающаяся как справа налево, так и слева направо).\nВходные данные\nНепустая строка длиной не более 100 символов. Строка состоит только из заглавных латинских литер.\nВыходные данные\nВывести строку-палиндром максимальной длины, которую можно получить из исходной вычёркиванием нескольких букв. При наличии нескольких решений необходимо вывести одно (любое) из них.", "compiler": "Judge C++", "send_date": "30 дек. 2016 г., 22:01:25", "time": 4.06, "memory": 1044, "code": "#include <string>\n#include<bits/stdc++.h>\n#include <iostream>\nusing namespace std;\nstring max1(string a, string b)\n{\nif(a.length() >= b.length()) return a;\nreturn b;\n}\nstring max1(string a, string b, string c)\n{\nreturn max(a, max(b, c));\n}\nint main()\n{\n    string s;\n    cin >> s;\n    int L = s.length();\n    string d[101][101];\n    int i,j;\n    string t = \"!\";\n    for(i=0;i<L;i++)\n        d[i][i] = s[i];\n    i=1;\n    for(i=1;i<L;i++)\n    {\n        for(j=i;j<L;j++)\n        {\n            int g = j-i;\n            if(s[g]!=s[j])\n            {\n                d[g][j] = max1(d[g][j-1],d[g+1][j]);\n            }else\n            {\n                d[g][j] = max1(d[g][j-1], max1(d[g+1][j], s[g] + d[g+1][j-1] + s[j]));\n            }\n        }\n    }\ncout << d[0][L-1] << endl;;\n\n}", "link": "https://www.e-olymp.com/ru/problems/5062"}