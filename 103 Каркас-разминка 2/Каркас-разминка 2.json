{"name": "Каркас-разминка 2", "text": "Каркас-разминка 2\nНайдите пару вершин в полном неориентированном взвешенном графе согласно заданного критерия.\nВходные данные\nВо входном файле задано число N (от 2 до 100) и матрица смежности полного неориентированного взвешенного графа (полный граф - граф, в котором есть ребра между всеми парами вершин). Все веса ребер - натуральные числа от 1 до 1000. Далее дано N чисел, каждое из которых либо 0, либо 1 - считается, что эти числа записаны в вершинах. Гарантируется, что есть хотя бы один 0 и хотя бы одна 1.\nВыходные данные\nНайдите и выведите в выходной файл такие две вершины, что:\nв первой из них стоит 0\nво второй из них стоит 1\nвес ребра между этими вершинами минимально возможный.\nЕсли таких пар несколько, выведите любую из них.", "compiler": "Judge C++", "send_date": "24 сент. 2017 г., 16:22:06", "time": 7.7, "memory": 1752, "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nvector <int> a0;\nvector <int> a1;\npair<int,int> ans;\nbool check(int a, int b){\n    if(a == 0 && b == 1)\n        return true;\n    if(a == 1 && b == 0)\n        return true;\n    return false;\n}\nmain()\n{\n    int n;\n    cin >> n;\n    int a;\n    int A[n][n];\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            cin >> a;\n            A[i][j] = a;\n        }\n    }\n    int m = LLONG_MAX;\n    for(int i = 0; i < n; i++){\n        cin >> a;\n        if(a)\n            a1.push_back(i);\n        else\n            a0.push_back(i);\n    }\n     for(auto &a : a0) {\n        for(auto &b : a1) {\n            if(m > A[a][b]) {\n                m = A[a][b];\n                ans = {a, b};\n            }\n        }\n    }\n    cout << ans.first+1 << \" \" << ans.second+1 << endl;\n}", "link": "https://www.e-olymp.com/ru/problems/980"}