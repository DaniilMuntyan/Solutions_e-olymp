{"name": "Кратчайший путь", "text": "Кратчайший путь\nЗадан неориентированный граф. Найдите кратчайший путь от вершины a до вершины b.\nВходные данные\nВ первой строке находится два целых числа n и m (1 ≤ n ≤ 50000, 1 ≤ m ≤ 100000) - количества вершин и рёбер соответственно. Во второй строке заданы целые числа a и b - стартовая и конечная вершина соответственно. Далее идут m строк, описывающие рёбра.\nВыходные данные\nЕсли пути между a и b нет, то выведите -1. Иначе выведите в первой строке длину l кратчайшего пути между этими двумя вершинами в рёбрах, а во второй строке выведите l + 1 число - вершины этого пути.", "compiler": "Judge C++", "send_date": "15 окт. 2017 г., 16:39:15", "time": 67.94, "memory": 5800, "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct S\n{\n    int L=0,p=0;\n};\nint n, s, f,i,j,a,m,b;\nvector <int> g[100000];\nvector <S> d(50000);\nqueue <int> Q;\nvector <int> r;\n\nvoid BFS(int s,int y)\n{\n d[s].L = 1;\n Q.push(s);\n while(!Q.empty())\n {\n  int k = Q.front();\n  Q.pop();\n  for(i=0;i<g[k].size();i++)\n   if(!d[g[k][i]].L)\n   {\n    d[g[k][i]].L = d[k].L + 1;\n     r.push_back(k);\n    Q.push(g[k][i]);\n                if(g[k][i]==y)\n                    return;\n   }\n }\n}\nint main()\n{\n cin >> n >> m >> s >> f;\n\n  for(j=1;j<=m;j++)\n  {\n   cin >> a >> b;\n    g[a].push_back(b);\n                g[b].push_back(a);\n  }\n        BFS(s,f);\n        if(d[f].L-1==-1){\n        cout << d[f].L-1 << endl;\n        exit(0);\n        }else\n          cout << d[f].L-1 << endl;\n       for(i=0;i<r.size();i++)\n        cout << r[i] << \" \";\n       cout << f << endl;\n      //  cout << f << endl;\n}", "link": "https://www.e-olymp.com/ru/problems/4853"}